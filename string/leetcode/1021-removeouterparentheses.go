package leetcode

import "strings"

/*
删除最外层的括号
Category	Difficulty	Likes	Dislikes
algorithms	Easy (77.95%)	140	-
Tags
Companies
有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。



示例 1：

输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
示例 2：

输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
示例 3：

输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。


提示：

S.length <= 10000
S[i] 为 "(" 或 ")"
S 是一个有效括号字符串
*/

/*
       0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
输入："( ( ) ( ) ) ( ( ) )  (  (  )  (  (  )  )  )"
       ×         √ ×     √  ×                    √
--------------------------------------------------------------
打了 × 的地方是每次 i += 1 滤过的地方
打了√ 的位置 l=r, 表示是外层括号，此时直接设置 i += 1 --->(1, 7, 11) 集合是每次i开始的地方
同时标记 l=1,r=0,表示左右括号重新计数

*/
func RemoveOuterParentess(s string) string {
	p := "()"

	// l 初始化为1，肯定了第一个字符为(, 就是说左括号数量 +1
	l, r := 1, 0

	var so strings.Builder

	for i := 1; i < len(s); i++ {
		if s[i] == p[0] {
			l += 1
		} else {
			r += 1
		}

		if r != l {
			// 因为开始处已经排除了左括号，所以r 和l 不等的地方都是结果
			so.WriteByte(s[i])
		} else {
			// r == l 时，表示找到等量的( 和 ), 把外层去掉就是
			// 内层需要的括号了

			// i 再次 +1 表示第二组括号对开始以 ( 开始，自动把它屏蔽
			i += 1

			// l=1, 表示第二组第一个肯定是 (， 计入左括号中
			l = 1
			r = 0
		}
	}

	return so.String()
}
